<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ENTROPY</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #0a0a0a;
  --surface: #111;
  --border: #1a1a1a;
  --border-bright: #2a2a2a;
  --text: #e0e0e0;
  --text-dim: #555;
  --text-muted: #333;
  --red: #e53e3e;
  --red-dim: rgba(229,62,62,.15);
  --orange: #dd6b20;
  --yellow: #d69e2e;
  --green: #38a169;
  --cyan: #4fd1c5;
}
* { margin:0; padding:0; box-sizing:border-box; }
html, body { width:100%; height:100%; background:var(--bg); font-family:'Inter',sans-serif; color:var(--text); overflow:hidden; }

/* Layout */
#app { display:grid; grid-template-columns:1fr 340px; grid-template-rows:56px 1fr; height:100%; }

/* Top bar */
#topbar {
  grid-column:1/-1; display:flex; align-items:center; justify-content:space-between;
  padding:0 24px; border-bottom:1px solid var(--border);
  background:rgba(10,10,10,.95); backdrop-filter:blur(10px); z-index:10;
}
#topbar .logo { display:flex; align-items:center; gap:12px; }
#topbar .logo-text { font-family:'Space Mono',monospace; font-size:14px; font-weight:700; letter-spacing:6px; color:var(--text); }
#topbar .logo-dot { width:8px; height:8px; border-radius:50%; background:var(--red); animation:pulse-dot 2s ease-in-out infinite; }
@keyframes pulse-dot { 0%,100%{opacity:1;box-shadow:0 0 0 0 rgba(229,62,62,.4)} 50%{opacity:.7;box-shadow:0 0 0 8px rgba(229,62,62,0)} }
#topbar .meta { display:flex; align-items:center; gap:20px; font-size:11px; color:var(--text-dim); font-family:'Space Mono',monospace; }
#topbar .meta a { color:var(--text-dim); text-decoration:none; transition:color .2s; }
#topbar .meta a:hover { color:var(--text); }

/* Main canvas area */
#main { position:relative; overflow:hidden; }
canvas#graph { width:100%; height:100%; display:block; }

/* Big entropy number overlay */
#entropy-display {
  position:absolute; top:24px; left:28px; z-index:5;
}
#entropy-label { font-size:10px; letter-spacing:4px; color:var(--text-dim); font-family:'Space Mono',monospace; text-transform:uppercase; }
#entropy-value { font-size:72px; font-weight:700; line-height:1; margin-top:2px; font-family:'Space Mono',monospace; }
#entropy-unit { font-size:18px; color:var(--text-dim); margin-left:2px; }
#entropy-subtitle { font-size:11px; color:var(--text-dim); margin-top:6px; font-family:'Space Mono',monospace; }

/* Sidebar */
#sidebar {
  border-left:1px solid var(--border); overflow-y:auto; background:var(--surface);
  display:flex; flex-direction:column;
}
#sidebar::-webkit-scrollbar { width:4px; }
#sidebar::-webkit-scrollbar-thumb { background:var(--border-bright); border-radius:2px; }

#sidebar-header {
  padding:16px 20px 12px; border-bottom:1px solid var(--border);
  font-family:'Space Mono',monospace; font-size:10px; letter-spacing:3px;
  color:var(--text-dim); text-transform:uppercase;
}

.node-card {
  padding:14px 20px; border-bottom:1px solid var(--border);
  cursor:pointer; transition:background .15s;
}
.node-card:hover { background:rgba(255,255,255,.02); }
.node-card-top { display:flex; justify-content:space-between; align-items:center; }
.node-name { font-size:13px; font-weight:600; }
.node-pct { font-family:'Space Mono',monospace; font-size:14px; font-weight:700; }
.node-bar { height:2px; background:var(--border); margin-top:8px; border-radius:1px; overflow:hidden; }
.node-bar-fill { height:100%; border-radius:1px; transition:width .8s ease; }
.node-trend { font-size:11px; color:var(--text-dim); margin-top:6px; line-height:1.4; }

/* Tooltip */
#tooltip {
  position:fixed; z-index:20; display:none;
  background:rgba(17,17,17,.96); border:1px solid var(--border-bright);
  padding:12px 16px; font-size:12px; max-width:260px;
  box-shadow:0 8px 32px rgba(0,0,0,.6); border-radius:4px;
  pointer-events:none;
}
#tooltip .tt-name { font-weight:700; font-size:13px; margin-bottom:4px; }
#tooltip .tt-inf { font-family:'Space Mono',monospace; font-weight:700; }
#tooltip .tt-trend { color:var(--text-dim); font-size:11px; margin-top:6px; }

/* Mobile */
@media(max-width:768px){
  #app { grid-template-columns:1fr; grid-template-rows:48px 1fr 40vh; }
  #topbar .meta span:not(:first-child) { display:none; }
  #entropy-value { font-size:48px; }
  #sidebar { border-left:none; border-top:1px solid var(--border); }
}
</style>
</head>
<body>
<div id="app">
  <div id="topbar">
    <div class="logo">
      <div class="logo-dot"></div>
      <div class="logo-text">ENTROPY</div>
    </div>
    <div class="meta">
      <span id="status-text">MONITORING</span>
      <span id="node-count">—</span>
      <a href="https://x.com/entropyindex" target="_blank">@entropyindex</a>
      <a href="https://github.com/entropyindex/entropy" target="_blank">github</a>
    </div>
  </div>

  <div id="main">
    <canvas id="graph"></canvas>
    <div id="entropy-display">
      <div id="entropy-label">Global Entropy Index</div>
      <div id="entropy-value"><span id="pct">—</span><span id="entropy-unit">%</span></div>
      <div id="entropy-subtitle">real-time chaos measurement</div>
    </div>
  </div>

  <div id="sidebar">
    <div id="sidebar-header">Communities</div>
    <div id="node-list"></div>
  </div>
</div>

<div id="tooltip">
  <div class="tt-name" id="tt-name"></div>
  <div class="tt-inf" id="tt-inf"></div>
  <div class="tt-trend" id="tt-trend"></div>
</div>

<script>
(function(){
const canvas = document.getElementById('graph');
const ctx = canvas.getContext('2d');
let W, H, dpr;
let state = null, nodes = [], hoverNode = null, mouseX = -1, mouseY = -1;
let particles = [];
let time = 0;

function resize(){
  const rect = canvas.parentElement.getBoundingClientRect();
  dpr = window.devicePixelRatio || 1;
  W = rect.width; H = rect.height;
  canvas.width = W * dpr; canvas.height = H * dpr;
  canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  if(nodes.length) updatePositions();
}
window.addEventListener('resize', resize);

// Color based on infection
function getColor(pct) {
  if (pct < 30) return { r:56, g:178, b:115, hex:'#38b273' };    // green
  if (pct < 50) return { r:214, g:158, b:46, hex:'#d69e2e' };     // yellow
  if (pct < 70) return { r:221, g:107, b:32, hex:'#dd6b20' };     // orange
  return { r:229, g:62, b:62, hex:'#e53e3e' };                     // red
}

function updatePositions(){
  for(const n of nodes){
    n.px = n.x * W;
    n.py = n.y * H;
  }
}

// Edge particles
function spawnEdgeParticles(){
  particles = [];
  if(!nodes.length) return;
  for(const n of nodes){
    for(const cid of n.connections){
      const other = nodes.find(o => o.id === cid);
      if(!other || other.id > n.id) continue;
      const avgInf = (n.infection + other.infection) / 200;
      if(avgInf > 0.3){
        const count = Math.ceil(avgInf * 3);
        for(let i = 0; i < count; i++){
          particles.push({
            from: n, to: other,
            t: Math.random(),
            speed: 0.002 + avgInf * 0.004,
            size: 1 + avgInf * 2,
            inf: avgInf
          });
        }
      }
    }
  }
}

function draw(ts){
  time = ts;
  ctx.clearRect(0, 0, W, H);

  // Subtle grid
  ctx.strokeStyle = 'rgba(255,255,255,.015)';
  ctx.lineWidth = 1;
  const grid = 60;
  for(let x = 0; x < W; x += grid){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  for(let y = 0; y < H; y += grid){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }

  if(!state) return requestAnimationFrame(draw);

  // Edges
  for(const n of nodes){
    for(const cid of n.connections){
      const other = nodes.find(o => o.id === cid);
      if(!other || other.id > n.id) continue;
      const avgInf = (n.infection + other.infection) / 200;
      ctx.beginPath();
      ctx.moveTo(n.px, n.py);
      ctx.lineTo(other.px, other.py);
      ctx.strokeStyle = `rgba(255,255,255,${0.03 + avgInf * 0.06})`;
      ctx.lineWidth = 0.5 + avgInf;
      ctx.stroke();
    }
  }

  // Edge particles
  for(const p of particles){
    p.t += p.speed;
    if(p.t > 1) p.t -= 1;
    const px = p.from.px + (p.to.px - p.from.px) * p.t;
    const py = p.from.py + (p.to.py - p.from.py) * p.t;
    const c = getColor(p.inf * 100);
    ctx.beginPath();
    ctx.arc(px, py, p.size, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(${c.r},${c.g},${c.b},${0.4 + p.inf * 0.4})`;
    ctx.fill();
  }

  // Nodes
  for(const n of nodes){
    const inf = n.infection / 100;
    const c = getColor(n.infection);
    const isHover = hoverNode === n;
    const baseR = 6 + inf * 18;
    const pulse = 1 + 0.08 * Math.sin(ts / 600 + n.infection / 5) * inf;
    const r = baseR * pulse;

    // Glow
    const grad = ctx.createRadialGradient(n.px, n.py, 0, n.px, n.py, r * 4);
    grad.addColorStop(0, `rgba(${c.r},${c.g},${c.b},${0.08 + inf * 0.12})`);
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.beginPath(); ctx.arc(n.px, n.py, r * 4, 0, Math.PI * 2);
    ctx.fillStyle = grad; ctx.fill();

    // Ring
    ctx.beginPath(); ctx.arc(n.px, n.py, r, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(${c.r},${c.g},${c.b},${isHover ? 0.3 : 0.12})`;
    ctx.fill();
    ctx.strokeStyle = `rgba(${c.r},${c.g},${c.b},${isHover ? 0.9 : 0.5})`;
    ctx.lineWidth = isHover ? 2 : 1;
    ctx.stroke();

    // Center dot
    ctx.beginPath(); ctx.arc(n.px, n.py, 2 + inf * 2, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(${c.r},${c.g},${c.b},${0.8 + inf * 0.2})`;
    ctx.fill();

    // Label
    const fs = 10;
    ctx.font = `${isHover ? '600' : '400'} ${fs}px 'Inter'`;
    ctx.textAlign = 'center';
    ctx.fillStyle = `rgba(255,255,255,${isHover ? 0.9 : 0.45})`;
    ctx.fillText(n.name.toUpperCase(), n.px, n.py + r + 16);

    // Pct under name
    ctx.font = `700 ${fs}px 'Space Mono'`;
    ctx.fillStyle = `rgba(${c.r},${c.g},${c.b},${isHover ? 1 : 0.6})`;
    ctx.fillText(n.infection + '%', n.px, n.py + r + 28);
  }

  requestAnimationFrame(draw);
}

// Tooltip
const tooltip = document.getElementById('tooltip');
canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  mouseX = e.clientX - rect.left; mouseY = e.clientY - rect.top;
  hoverNode = null;
  for(const n of nodes){
    const dx = mouseX - n.px, dy = mouseY - n.py;
    if(Math.sqrt(dx*dx+dy*dy) < 30 + n.infection/100*18){ hoverNode = n; break; }
  }
  if(hoverNode){
    const c = getColor(hoverNode.infection);
    document.getElementById('tt-name').textContent = hoverNode.name;
    document.getElementById('tt-inf').textContent = hoverNode.infection + '% infected';
    document.getElementById('tt-inf').style.color = c.hex;
    document.getElementById('tt-trend').textContent = hoverNode.trend;
    tooltip.style.display = 'block';
    tooltip.style.left = (e.clientX + 16) + 'px';
    tooltip.style.top = (e.clientY - 10) + 'px';
  } else {
    tooltip.style.display = 'none';
  }
});
canvas.addEventListener('mouseleave', () => { hoverNode = null; tooltip.style.display = 'none'; });

// Sidebar
function renderSidebar(){
  if(!state) return;
  const sorted = [...nodes].sort((a,b) => b.infection - a.infection);
  const list = document.getElementById('node-list');
  list.innerHTML = '';
  for(const n of sorted){
    const c = getColor(n.infection);
    const card = document.createElement('div');
    card.className = 'node-card';
    card.innerHTML = `
      <div class="node-card-top">
        <span class="node-name">${n.name}</span>
        <span class="node-pct" style="color:${c.hex}">${n.infection}%</span>
      </div>
      <div class="node-bar"><div class="node-bar-fill" style="width:${n.infection}%;background:${c.hex}"></div></div>
      <div class="node-trend">${n.trend}</div>
    `;
    card.addEventListener('mouseenter', () => { hoverNode = n; });
    card.addEventListener('mouseleave', () => { hoverNode = null; });
    list.appendChild(card);
  }
}

// Animate entropy counter
function animateEntropy(target){
  const el = document.getElementById('pct');
  const current = parseInt(el.textContent) || 0;
  if(current === target) return;
  const diff = target - current;
  const steps = 30;
  let step = 0;
  function tick(){
    step++;
    const val = Math.round(current + diff * (step / steps));
    el.textContent = val;
    // Color the number
    const c = getColor(val);
    el.style.color = c.hex;
    document.getElementById('entropy-unit').style.color = c.hex;
    if(step < steps) requestAnimationFrame(tick);
  }
  tick();
}

// Load
async function loadState(){
  try {
    const r = await fetch('world-state.json?t=' + Date.now());
    state = await r.json();
    nodes = state.nodes.map(n => ({...n, px: 0, py: 0}));
    updatePositions();
    spawnEdgeParticles();
    animateEntropy(state.globalEntropy);
    document.getElementById('node-count').textContent = state.totalNodes + ' nodes';
    document.getElementById('status-text').textContent = 'LIVE';
    renderSidebar();
  } catch(e) {
    document.getElementById('status-text').textContent = 'OFFLINE';
    console.error(e);
  }
}

resize();
loadState().then(() => requestAnimationFrame(draw));
setInterval(loadState, 30000);
})();
</script>
</body>
</html>
